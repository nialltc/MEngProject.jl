Index: src/LaminartGPU.jl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\n# module laminart\n\n- Julia version: 1.4\n- Author: niallcullinane\n- Date: 2020-06-07\n\n# Examples\n\n```jldoctest\njulia>\n```\n\"\"\"\nmodule LaminartGPU\ninclude(\"./LamKernels.jl\")\n\nusing NNlib, ImageFiltering, Images, OffsetArrays, CUDA\n# , MEngProject.LamKernels\n\nexport I_u, fun_v_C, fun_equ\n\nmutable struct LamFunction{T <: AbstractArray} <: Function\n\tx::T\n\tm::T\n\ts::T\n\t\n\tx_lgn::T\n\tC::T\n\tH_z::T\n\t\n\tdy_temp::T\n\tdm_temp::T\n\tdz_temp::T\n\tds_temp::T\n\tdv_temp::T\n\tH_z_temp::T\n\tV_temp_1::T\n\tV_temp_2::T\n\tQ_temp::T\n\tP_temp::T\nend\n\n\nfunction (ff::LamFunction)(du, u, p, t)\n\n       @inbounds begin\n\n\t\t@. ff.x = @view u[:, :, 1:p.K,:]\n        y = @view u[:, :, p.K+1:2*p.K,:]\n        @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n        z = @view u[:, :, 3*p.K+1:4*p.K,:]\n\t\t@. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n\t\tv_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tv_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\tdx = @view du[:, :, 1:p.K,:]\n        dy = @view du[:, :, p.K+1:2*p.K,:]\n        dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n        dz = @view du[:, :, 3*p.K+1:4*p.K,:]\n        ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n\t\tdv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tdv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\tfun_x_lgn!(ff.x_lgn, ff.x, p)\n        fun_v_C!(ff.C, v_p, v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n        fun_H_z!(ff.H_z, z, ff.H_z_temp, p)\n\n        fun_dv!(dv_p, v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n        fun_dv!(dv_m, v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n        fun_dx_v1!(dx, ff.x, ff.C, z, p.x_V2, p)\n        fun_dy!(dy, y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n        fun_dm!(dm, ff.m, ff.x, ff.dm_temp, p)\n        fun_dz!(dz, z, y, ff.H_z, ff.s, ff.dz_temp, p)\n        fun_ds!(ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n    end\n    return nothing\n\nend\n\n\nmutable struct LamFunction_allStruct <: Function\n\tx::AbstractArray\n\ty::AbstractArray\n\tm::AbstractArray\n\tz::AbstractArray\n\ts::AbstractArray\n\tv_p::AbstractArray\n\tv_m::AbstractArray\n\n\tdx::AbstractArray\n\tdy::AbstractArray\n\tdm::AbstractArray\n\tdz::AbstractArray\n\tds::AbstractArray\n\tdv_p::AbstractArray\n\tdv_m::AbstractArray\n\t\n\tx_lgn::AbstractArray\n\tC::AbstractArray\n\tH_z::AbstractArray\n\t\n\tdy_temp::AbstractArray\n\tdm_temp::AbstractArray\n\tdz_temp::AbstractArray\n\tds_temp::AbstractArray\n\tdv_temp::AbstractArray\n\tH_z_temp::AbstractArray\n\tV_temp_1::AbstractArray\n\tV_temp_2::AbstractArray\n\tQ_temp::AbstractArray\n\tP_temp::AbstractArray\nend\n\n\nfunction (ff::LamFunction_allStruct)(du, u, p, t)\n\n       @inbounds begin\n\n\t\t@. ff.x = @view u[:, :, 1:p.K,:]\n        ff.y = @view u[:, :, p.K+1:2*p.K,:]\n        @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n        ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n\t\t@. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n\t\tff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\tff.dx = @view du[:, :, 1:p.K,:]\n        ff.dy = @view du[:, :, p.K+1:2*p.K,:]\n        ff.dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n        ff.dz = @view du[:, :, 3*p.K+1:4*p.K,:]\n        ff.ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n\t\tff.dv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tff.dv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\tfun_x_lgn!(ff.x_lgn, ff.x, p)\n        fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n        fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n        fun_dv!(ff.dv_p, ff.v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n        fun_dv!(ff.dv_m, ff.v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n        fun_dx_v1!(ff.dx, ff.x, ff.C, ff.z, p.x_V2, p)\n        fun_dy!(ff.dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n        fun_dm!(ff.dm, ff.m, ff.x, ff.dm_temp, p)\n        fun_dz!(ff.dz, ff.z, ff.y, ff.H_z, ff.s, ff.dz_temp, p)\n        fun_ds!(ff.ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n\n    end\n    return nothing\n\nend\n\n\n\nmutable struct LamFunction_gpu_reuse{T <: AbstractArray} <: Function\n\n\tx_lgn::T\n\tC::T\n\tH_z::T\n\t\n\ttmp_a::T\n\ttmp_b::T\n\t\n\ttmp_A::T\n\ttmp_B::T\n\ttmp_C::T\nend\n\n\nfunction (ff::LamFunction_gpu_reuse)(du, u, p, t)\n\n       @inbounds begin\n\n\t\t\n        y = @view u[:, :, p.K+1:2*p.K,:]\n\t\tz = @view u[:, :, 3*p.K+1:4*p.K,:]\n\t\t\n\t\tv_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tv_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\tdx = @view du[:, :, 1:p.K,:]\n        dy = @view du[:, :, p.K+1:2*p.K,:]\n        dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n\t\tdz = @view du[:, :, 3*p.K+1:4*p.K,:]\n        ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n\t\tdv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n\t\tdv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n\t\t\n        fun_v_C!(ff.C, v_p, v_m, ff.tmp_a, ff.tmp_b, ff.tmp_A, ff.tmp_B, p) #a,b,C,D: buffers\n        fun_H_z!(ff.H_z, z, ff.tmp_A, p) #A=buffer\n\n\t\t@. ff.tmp_A = @view u[:, :, 1:p.K,:] #x\n        @. ff.tmp_B = @view u[:, :, 2*p.K+1:3*p.K,:] #m\n\t\tfun_x_lgn!(ff.x_lgn, ff.tmp_A, p)\n\t\t\n        fun_dv!(dv_p, v_p, p.r, ff.x_lgn, ff.tmp_a, p) #a=buffer\n        fun_dv!(dv_m, v_m, .-p.r, ff.x_lgn, ff.tmp_a, p) #a=buff\n        \n\t\t\n\t\tfun_dx_v1!(dx, ff.tmp_A, ff.C, z, p.x_V2, p) #A:x\n        fun_dy!(dy, y, ff.C, ff.tmp_A, ff.tmp_B, ff.tmp_C, p) # A:x, B:m, C:buffer\n        fun_dm!(dm, ff.tmp_B, ff.tmp_A, ff.tmp_C, p) # A:x, B:m, C:buffer\n        \n\t\t@. ff.tmp_A = @view u[:, :, 4*p.K+1:5*p.K,:] #s\n\t\tfun_dz!(dz, z, y, ff.H_z, ff.tmp_A, ff.tmp_B, p) #A=s, B=buffer\n        fun_ds!(ds, ff.tmp_A, ff.H_z, ff.tmp_B, p) #A=s, B=buffer\n\t\t\n\n    end\n    return nothing\n\nend\n\n\n\n\n# mutable struct LamFunction_gpu30 <: Function\n# \tx_lgn::AbstractArray\n# \tC::AbstractArray\n# \tH_z::AbstractArray\n\t\n# \tdy_temp::AbstractArray\n# \tdm_temp::AbstractArray\n# \tdz_temp::AbstractArray\n# \tds_temp::AbstractArray\n# \tdv_temp::AbstractArray\n# \tH_z_temp::AbstractArray\n# \tV_temp_1::AbstractArray\n# \tV_temp_2::AbstractArray\n# \tQ_temp::AbstractArray\n# \tP_temp::AbstractArray\n# end\n\n\n# function (ff::LamFunction_gpu30)(du, u, p, t)\n\n#        @inbounds begin\n\n# \t\tff.x = @view u[:, :, 1:p.K,:]\n#         ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n# \t\t@. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n# \t\tff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# \t\tff.dx = @view du[:, :, 1:p.K,:]\n#         ff.dy = @view du[:, :, p.K+1:2*p.K,:]\n#         ff.dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n#         ff.dz = @view du[:, :, 3*p.K+1:4*p.K,:]\n#         ff.ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n# \t\tff.dv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tff.dv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# \t\tfun_x_lgn!(ff.x_lgn, ff.x, p)\n#         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n#         fun_dv!(ff.dv_p, ff.v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dv!(ff.dv_m, ff.v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dx_v1!(ff.dx, ff.x, ff.C, ff.z, p.x_V2, p)\n#         fun_dy!(ff.dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n#         fun_dm!(ff.dm, ff.m, ff.x, ff.dm_temp, p)\n#         fun_dz!(ff.dz, ff.z, ff.y, ff.H_z, ff.s, ff.dz_temp, p)\n#         fun_ds!(ff.ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n\n#     end\n#     return nothing\n\n# end\n\n\n# mutable struct LamFunction_gpu14{T <: CuArray{Float32,4,Nothing}} <: Function\n# \tx::T\n# \ty::T\n# \tm::T\n# \tz::T\n# \ts::T\n# \tv_p::T\n# \tv_m::T\n\n# # \tdx::T\n# # \tdy::T\n# # \tdm::T\n# # \tdz::T\n# # \tds::T\n# # \tdv_p::T\n# # \tdv_m::T\n\t\n# \tx_lgn::T\n# \tC::T\n# \tH_z::T\n\t\n# \tdy_temp::T\n# \tdm_temp::T\n# \tdz_temp::T\n# \tds_temp::T\n# \tdv_temp::T \n# \tH_z_temp::T\n# \tV_temp_1::T\n# \tV_temp_2::T\n# \tQ_temp::T\n# \tP_temp::T\n# end\n\n\n# function (ff::LamFunction_gpu14)(du, u, p, t)\n\n#        @inbounds begin\n# #         @. ff.x = @view u[:, :, 1:p.K,:]\n# #         @. ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n# #         @. ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n#         @. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n# #        @. ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# # \t\t@. ff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\n# \t\tx = @view u[:, :, 1:p.K,:]\n#         y = @view u[:, :, p.K+1:2*p.K,:]\n# #         m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         z = @view u[:, :, 3*p.K+1:4*p.K,:]\n# #         s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n#        v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tv_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# \t\t dx = @view du[:, :, 1:p.K,:]\n#         dy = @view du[:, :, p.K+1:2*p.K,:]\n#         dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n#         dz = @view du[:, :, 3*p.K+1:4*p.K,:]\n#         ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n#        dv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tdv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# #         fun_x_lgn!(ff.x_lgn, ff.x, p)\n# #         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n# #         fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n# #         fun_dv!(dv_p, ff.v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n# #         fun_dv!(dv_m, ff.v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n# #         fun_dx_v1!(dx, ff.x, ff.C, ff.z, p.x_V2, p)\n# #         fun_dy!(dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n# #         fun_dm!(dm, ff.m, ff.x, ff.dm_temp, p)\n# #         fun_dz!(dz, ff.z, ff.y, ff.H_z, ff.s, ff.dz_temp, p)\n# #         fun_ds!(ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n# # \t\tfun_x_lgn!(ff.x_lgn, x, p)\n#         fun_v_C!(ff.C, v_p, v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, z, ff.H_z_temp, p)\n\n#         fun_dv!(dv_p, v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dv!(dv_m, v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dx_v1!(dx, x, ff.C, z, p.x_V2, p)\n#         fun_dy!(dy, y, ff.C, x, ff.m, ff.dy_temp, p)\n#         fun_dm!(dm, ff.m, x, ff.dm_temp, p)\n#         fun_dz!(dz, z, y, ff.H_z, ff.s, ff.dz_temp, p)\n#         fun_ds!(ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n\t\t\n# # \t\t@. du[:, :, 1:p.K,:] = ff.dx\n# # \t\t@. du[:, :, p.K+1:2*p.K,:] = ff.dy\n# # \t\t@. du[:, :, 2*p.K+1:3*p.K,:] = ff.dm\n# # \t\t@. du[:, :, 3*p.K+1:4*p.K,:] = ff.dz\n# # \t\t@. du[:, :, 4*p.K+1:5*p.K,:] = ff.ds\n\n# #         @. du[:, :, 5*p.K+1:5*p.K+1,:] = ff.dv_p\n# # \t\t@. du[:, :, 5*p.K+2:5*p.K+2,:] = ff.dv_m\n\n#     end\n#     return nothing\n\n# end\n\n\n\n# mutable struct LamFunction_gpu14{T <: CuArray{Float32,4,Nothing}} <: Function\n# \tx::T\n# \ty::T\n# \tm::T\n# \tz::T\n# \ts::T\n# \tv_p::T\n# \tv_m::T\n\n# # \tdx::T\n# # \tdy::T\n# # \tdm::T\n# # \tdz::T\n# # \tds::T\n# # \tdv_p::T\n# # \tdv_m::T\n\t\n# \tx_lgn::T\n# \tC::T\n# \tH_z::T\n\t\n# \tdy_temp::T\n# \tdm_temp::T\n# \tdz_temp::T\n# \tds_temp::T\n# \tdv_temp::T \n# \tH_z_temp::T\n# \tV_temp_1::T\n# \tV_temp_2::T\n# \tQ_temp::T\n# \tP_temp::T\n# end\n\n\n# function (ff::LamFunction_gpu14)(du, u, p, t)\n\n#        @inbounds begin\n# #         @. ff.x = @view u[:, :, 1:p.K,:]\n# #         @. ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n# #         @. ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n#         @. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n# #        @. ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# # \t\t@. ff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\n# \t\tx = @view u[:, :, 1:p.K,:]\n#         y = @view u[:, :, p.K+1:2*p.K,:]\n# #         m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         z = @view u[:, :, 3*p.K+1:4*p.K,:]\n# #         s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n#        v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tv_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# \t\t dx = @view du[:, :, 1:p.K,:]\n#         dy = @view du[:, :, p.K+1:2*p.K,:]\n#         dm = @view du[:, :, 2*p.K+1:3*p.K,:]\n#         dz = @view du[:, :, 3*p.K+1:4*p.K,:]\n#         ds = @view du[:, :, 4*p.K+1:5*p.K,:]\n\n#        dv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\tdv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# #         fun_x_lgn!(ff.x_lgn, ff.x, p)\n# #         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n# #         fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n# #         fun_dv!(dv_p, ff.v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n# #         fun_dv!(dv_m, ff.v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n# #         fun_dx_v1!(dx, ff.x, ff.C, ff.z, p.x_V2, p)\n# #         fun_dy!(dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n# #         fun_dm!(dm, ff.m, ff.x, ff.dm_temp, p)\n# #         fun_dz!(dz, ff.z, ff.y, ff.H_z, ff.s, ff.dz_temp, p)\n# #         fun_ds!(ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n# # \t\tfun_x_lgn!(ff.x_lgn, x, p)\n#         fun_v_C!(ff.C, v_p, v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, z, ff.H_z_temp, p)\n\n#         fun_dv!(dv_p, v_p, p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dv!(dv_m, v_m, .-p.r, ff.x_lgn, ff.dv_temp, p)\n#         fun_dx_v1!(dx, x, ff.C, z, p.x_V2, p)\n#         fun_dy!(dy, y, ff.C, x, ff.m, ff.dy_temp, p)\n#         fun_dm!(dm, ff.m, x, ff.dm_temp, p)\n#         fun_dz!(dz, z, y, ff.H_z, ff.s, ff.dz_temp, p)\n#         fun_ds!(ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n\t\t\n# # \t\t@. du[:, :, 1:p.K,:] = ff.dx\n# # \t\t@. du[:, :, p.K+1:2*p.K,:] = ff.dy\n# # \t\t@. du[:, :, 2*p.K+1:3*p.K,:] = ff.dm\n# # \t\t@. du[:, :, 3*p.K+1:4*p.K,:] = ff.dz\n# # \t\t@. du[:, :, 4*p.K+1:5*p.K,:] = ff.ds\n\n# #         @. du[:, :, 5*p.K+1:5*p.K+1,:] = ff.dv_p\n# # \t\t@. du[:, :, 5*p.K+2:5*p.K+2,:] = ff.dv_m\n\n#     end\n#     return nothing\n\n# end\n\n\n\n\n\n# mutable struct LamFunction_gpu2{T <: CuArray{Float32,4,Nothing}} <: Function\n# \tx::T\n# \ty::T\n# \tm::T\n# \tz::T\n# \ts::T\n# \tv_p::T\n# \tv_m::T\n\t\n# \tdx::T\n# \tdy::T\n# \tdm::T\n# \tdz::T\n# \tds::T\n# \tdv_p::T\n# \tdv_m::T\n\t\n# \tx_lgn::T\n# \tC::T\n# \tH_z::T\n# \tdy_temp::T\n# \tds_temp::T\n# \tH_z_temp::T\n# \tV_temp_1::T\n# \tV_temp_2::T\n# \tQ_temp::T\n# \tP_temp::T\n# end\n\n# mutable struct LamFunction_cpu2{T <: AbstractArray} <: Function\n# \tx::T\n# \ty::T\n# \tm::T\n# \tz::T\n# \ts::T\n# \tv_p::T\n# \tv_m::T\n\t\n# \tdx::T\n# \tdy::T\n# \tdm::T\n# \tdz::T\n# \tds::T\n# \tdv_p::T\n# \tdv_m::T\n\t\n# \tx_lgn::T\n# \tC::T\n# \tH_z::T\n# \tds_temp::T\n# \t\tH_z_temp::T\n# \tV_temp_1::T\n# \tV_temp_2::T\n# \tQ_temp::T\n# \tP_temp::T\n# end\n\n# mutable struct LamFunction{T} <: Function\n# \tx::AbstractArray\n# \ty::AbstractArray\n# \tm::AbstractArray\n# \tz::AbstractArray\n# \ts::AbstractArray\n# \tv_p::AbstractArray\n# \tv_m::AbstractArray\n\t\n# \tdx::AbstractArray\n# \tdy::AbstractArray\n# \tdm::AbstractArray\n# \tdz::AbstractArray\n# \tds::AbstractArray\n# \tdv_p::AbstractArray\n# \tdv_m::AbstractArray\n\t\n# \tx_lgn::AbstractArray\n# \tC::AbstractArray\n# \tH_z::AbstractArray\n# \tV_temp_1::AbstractArray\n# \tV_temp_2::AbstractArray\n# \tQ_temp::AbstractArray\n# \tP_temp::AbstractArray\n# end\n\n# function (ff::LamFunction_cpu2)(du, u, p, t)\n\n#     @inbounds begin\n#         @. ff.x = @view u[:, :, 1:p.K,:]\n#         @. ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         @. ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n#         @. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n#         @. ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\t@. ff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\n#         fun_x_lgn!(ff.x_lgn, ff.x, p)\n#         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n#         fun_dv!(ff.dv_p, ff.v_p, p.r, ff.x_lgn, p)\n#         fun_dv!(ff.dv_m, ff.v_m, .-p.r, ff.x_lgn, p)\n#         fun_dx_v1!(ff.dx, ff.x, ff.C, ff.z, p.x_V2, p)\n#         fun_dy!(ff.dy, ff.y, ff.C, ff.x, ff.m, p)\n#         fun_dm!(ff.dm, ff.m, ff.x, p)\n#         fun_dz!(ff.dz, ff.z, ff.y, ff.H_z, ff.s, p)\n#         fun_ds!(ff.ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n# \t\t@. du[:, :, 1:p.K,:] = ff.dx\n# \t\t@. du[:, :, p.K+1:2*p.K,:] = ff.dy\n# \t\t@. du[:, :, 2*p.K+1:3*p.K,:] = ff.dm\n# \t\t@. du[:, :, 3*p.K+1:4*p.K,:] = ff.dz\n# \t\t@. du[:, :, 4*p.K+1:5*p.K,:] = ff.ds\n\n#         @. du[:, :, 5*p.K+1:5*p.K+1,:] = ff.dv_p\n# \t\t@. du[:, :, 5*p.K+2:5*p.K+2,:] = ff.dv_m\n\n#     end\n#     return nothing\n# end\n\n\n# function (ff::LamFunction_gpu2)(du, u, p, t)\n\n#        @inbounds begin\n#         @. ff.x = @view u[:, :, 1:p.K,:]\n#         @. ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         @. ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n#         @. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n#         @. ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\t@. ff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\n#         fun_x_lgn!(ff.x_lgn, ff.x, p)\n#         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, ff.z, ff.H_z_temp, p)\n\n#         fun_dv!(ff.dv_p, ff.v_p, p.r, ff.x_lgn, p)\n#         fun_dv!(ff.dv_m, ff.v_m, .-p.r, ff.x_lgn, p)\n#         fun_dx_v1!(ff.dx, ff.x, ff.C, ff.z, p.x_V2, p)\n#         fun_dy!(ff.dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n#         fun_dm!(ff.dm, ff.m, ff.x, p)\n#         fun_dz!(ff.dz, ff.z, ff.y, ff.H_z, ff.s, p)\n#         fun_ds!(ff.ds, ff.s, ff.H_z, ff.ds_temp, p)\n\t\t\n# \t\t@. du[:, :, 1:p.K,:] = ff.dx\n# \t\t@. du[:, :, p.K+1:2*p.K,:] = ff.dy\n# \t\t@. du[:, :, 2*p.K+1:3*p.K,:] = ff.dm\n# \t\t@. du[:, :, 3*p.K+1:4*p.K,:] = ff.dz\n# \t\t@. du[:, :, 4*p.K+1:5*p.K,:] = ff.ds\n\n#         @. du[:, :, 5*p.K+1:5*p.K+1,:] = ff.dv_p\n# \t\t@. du[:, :, 5*p.K+2:5*p.K+2,:] = ff.dv_m\n\n#     end\n#     return nothing\n\n# end\n\n\n\n\n\n# mutable struct LamFunction_04{T} <: Function\n# x::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# y::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# m::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# z::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# s::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# v_p::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# v_m::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dx::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dy::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dm::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dz::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# ds::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dv_p::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# dv_m::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tx_lgn::CuArray{Float32,4,Nothing}\n# \tC::CuArray{Float32,4,Nothing}\n# \tH_z::CuArray{Float32,4,Nothing}\n# \tV_temp_1::CuArray{Float32,4,Nothing}\n# \tV_temp_2::CuArray{Float32,4,Nothing}\n# \tQ_temp::CuArray{Float32,4,Nothing}\n# \tP_temp::CuArray{Float32,4,Nothing}\n# end\n\n# mutable struct LamFunction_10 <: Function\n# \tx\n# \ty\n# \tm\n# \tz\n# \ts\n# \tv_p\n# \tv_m\n# \tdx\n# \tdy\n# \tdm\n# \tdz\n# \tds\n# \tdv_p\n# \tdv_m\n# \tx_lgn\n# \tC\n# \tH_z\n# \tV_temp_1\n# \tV_temp_2\n# \tQ_temp\n# \tP_temp\n# end\n\n# mutable struct LamFunction_13<: Function\n# \tx::CuArray{Float32,4,Nothing}\n# \ty::CuArray{Float32,4,Nothing}\n# \tm::CuArray{Float32,4,Nothing}\n# \tz::CuArray{Float32,4,Nothing}\n# \ts::CuArray{Float32,4,Nothing}\n# \tv_p::CuArray{Float32,4,Nothing}\n# \tv_m::CuArray{Float32,4,Nothing}\n# dx::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tdy::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tdm::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tdz::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tds::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tdv_p::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tdv_m::SubArray{Float32,4,CuArray{Float32,4,Nothing},Tuple{Base.Slice{Base.OneTo{Int64}},Base.Slice{Base.OneTo{Int64}},UnitRange{Int64},Base.Slice{Base.OneTo{Int64}}},false}\n# \tx_lgn::CuArray{Float32,4,Nothing}\n# \tC::CuArray{Float32,4,Nothing}\n# \tH_z::CuArray{Float32,4,Nothing}\n# \tV_temp_1::CuArray{Float32,4,Nothing}\n# \tV_temp_2::CuArray{Float32,4,Nothing}\n# \tQ_temp::CuArray{Float32,4,Nothing}\n# \tP_temp::CuArray{Float32,4,Nothing}\n# end\n\n# function (ff::LamFunction_13)(du, u, p, t)\n\n#     @inbounds begin\n# #         ff.x = @view u[:, :, 1:p.K,:]\n# #         ff.y = @view u[:, :, p.K+1:2*p.K,:]\n# #         ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n# #         ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n# #         ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n# #         ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# # \t\tff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\n# \t\t@. ff.x = @view u[:, :, 1:p.K,:]\n#         @. ff.y = @view u[:, :, p.K+1:2*p.K,:]\n#         @. ff.m = @view u[:, :, 2*p.K+1:3*p.K,:]\n#         @. ff.z = @view u[:, :, 3*p.K+1:4*p.K,:]\n#         @. ff.s = @view u[:, :, 4*p.K+1:5*p.K,:]\n\n#         @. ff.v_p = @view u[:, :, 5*p.K+1:5*p.K+1,:]\n# \t\t@. ff.v_m = @view u[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# # \t\tff.dx = @view du[:, :, 1:p.K,:] \n# # \t\tff.dy = @view du[:, :, p.K+1:2*p.K,:] \n# # \t\tff.dm = @view du[:, :, 2*p.K+1:3*p.K,:] \n# # \t\tff.dz = @view du[:, :, 3*p.K+1:4*p.K,:] \n# # \t\tff.ds = @view du[:, :, 4*p.K+1:5*p.K,:] \n\n# # \t\tff.dv_p = @view du[:, :, 5*p.K+1:5*p.K+1,:]\n# # \t\tff.dv_m = @view du[:, :, 5*p.K+2:5*p.K+2,:]\n\t\t\n# # \t\tff.x_lgn = @view ff.x_lgn[:,:,:,:]\n# # \t\tff.C_ = @view ff.C[:,:,:,:]\n# # \t\tff.H_z_ = @view ff.H_z[:,:,:,:]\n# # \t\tff.V_temp_1_ = @view ff.V_temp_1[:,:,:,:]\n# # \t\tff.V_temp_2_ = @view ff.V_temp_2[:,:,:,:]\n# # \t\tff.Q_temp_ = @view ff.Q_temp[:,:,:,:]\n# # \t\tff.P_temp_ = @view ff.P_temp[:,:,:,:]\n\t\t\n#         fun_x_lgn!(ff.x_lgn, ff.x, p)\n#         fun_v_C!(ff.C, ff.v_p, ff.v_m, ff.V_temp_1, ff.V_temp_2, ff.Q_temp, ff.P_temp, p)\n#         fun_H_z!(ff.H_z, ff.z, p)\n\n#         fun_dv!(ff.dv_p, ff.v_p, p.r, ff.x_lgn, p)\n#         fun_dv!(ff.dv_m, ff.v_m, .-p.r, ff.x_lgn, p)\n#         fun_dx_v1!(ff.dx, ff.x, ff.C, ff.z, p.x_V2, p)\n#         fun_dy!(ff.dy, ff.y, ff.C, ff.x, ff.m, ff.dy_temp, p)\n#         fun_dm!(ff.dm, ff.m, ff.x, p)\n#         fun_dz!(ff.dz, ff.z, ff.y, ff.H_z, ff.s, p)\n#         fun_ds!(ff.ds, ff.s, ff.H_z, p)\n\t\t\n# # \t\t@. du[:, :, 1:p.K,:] = ff.dx\n# # \t\t@. du[:, :, p.K+1:2*p.K,:] = ff.dy\n# # \t\t@. du[:, :, 2*p.K+1:3*p.K,:] = ff.dm\n# # \t\t@. du[:, :, 3*p.K+1:4*p.K,:] = ff.dz\n# # \t\t@. du[:, :, 4*p.K+1:5*p.K,:] = ff.ds\n\n# #         @. du[:, :, 5*p.K+1:5*p.K+1,:] = ff.dv_p\n# # \t\t@. du[:, :, 5*p.K+2:5*p.K+2,:] = ff.dv_m\n\n#     end\n#     return nothing\n# end\n\n\n\n\nfunction kernels(img::AbstractArray, p::NamedTuple)\n       C_Q_temp = reshape(\n        Array{eltype(img)}(undef, p.C_AB_l, p.C_AB_l * p.K),\n        p.C_AB_l,\n        p.C_AB_l,\n        1,\n\t\tp.K\n    )\nC_P_temp = similar(C_Q_temp)\n\t    H_temp = reshape(\n        zeros(eltype(img), p.H_l, p.H_l * p.K * p.K),\n        p.H_l,\n        p.H_l,\n        p.K,\n    p.K)\n T_temp = reshape(Array{eltype(img)}(undef, p.K * p.K), 1, 1, p.K, p.K)     \n W_temp =\n        reshape(Array{eltype(img)}(undef, p.W_l, p.W_l * p.K * p.K), p.W_l, p.W_l, p.K, p.K)\n    for k ∈ 1:p.K\n        θ = π * (k - 1.0f0) / p.K\n        C_Q_temp[:, :, 1,k] = LamKernels.kern_d(p.σ_2, θ)          \n        C_P_temp[:, :, 1,k] = LamKernels.kern_b(p.σ_2, θ)               \n        H_temp[:, :, k,k] = p.H_fact .* LamKernels.gaussian_rot(p.H_σ_x, p.H_σ_y, θ, p.H_l)  \n# \t\ttodo make T kernel more general for higher K\n        T_temp[1, 1, k,1] = p.T_fact[k]\n        T_temp[1, 1, 2,2] = p.T_fact[1]\n        T_temp[1, 1, 1,2] = p.T_fact[2]\n        #todo: generalise T and W for higher K\n        #         T_temp[:,:,k] = KernelFactors.gaussian(p.T_σ, p.K)\n        #         for l ∈ 1:p.K\n        #             W_temp[:,:,l,k] =\n        #         end\n    end\n\n    W_temp[:, :, 1, 1] =\n        5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n        LamKernels.gaussian_rot(0.4f0, 1f0, 0f0, p.W_l)\n    \n\tW_temp[:, :, 2, 2] =\n        5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0,  π / 2f0, p.W_l) .+\n        LamKernels.gaussian_rot(0.4f0, 1f0, π / 2f0, p.W_l)\n    \n\tW_temp[:, :, 1, 2] = relu.(\n        0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n        LamKernels.gaussian_rot(0.3f0, 1.2f0, 0f0, p.W_l))\n    \n\tW_temp[:, :, 2, 1] = relu.(\n        0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, π / 2f0, p.W_l) .-\n        LamKernels.gaussian_rot(0.3f0, 1.2f0, π / 2f0, p.W_l))\n\t\n#     W_temp[:, :, 1, 1] =\n#         5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n#         LamKernels.gaussian_rot(0.4f0, 1f0, 0f0, p.W_l)\n#     W_temp[:, :, 2, 2] =\n#         5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n#         LamKernels.gaussian_rot(0.4f0, 1f0, π / 2f0, p.W_l)\n#     W_temp[:, :, 1, 2] = relu.(\n#         0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n#         LamKernels.gaussian_rot(0.3f0, 1.2f0, 0f0, p.W_l))\n#     W_temp[:, :, 2, 1] = relu.(\n#         0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n#         LamKernels.gaussian_rot(0.3f0, 1.2f0, π / 2f0, p.W_l))\n\t\ntemp_out = (\n        k_gauss_1 = cu(reshape2d_4d(Kernel.gaussian(p.σ_1))),\n        k_gauss_2 = cu(reshape2d_4d(Kernel.gaussian(p.σ_2))),\n        k_C_d = cu(C_Q_temp),\n        k_C_b = cu(C_P_temp),\n\t\t\n# \t\ttodo use mean of x_lgn?\n\t\tk_x_lgn = cu(reshape(ones(Float32,1,p.K),1,1,p.K,1)),\n# \t\tk_x_lgn = CuArray((reshape(ones(Float32,1,p.K),1,1,p.K,1))./p.K),\n        k_W_p = cu(W_temp),\n        k_W_m = cu(W_temp),\n        k_H = cu(H_temp),\n        k_T_p = cu(T_temp),\n        k_T_m = cu(p.T_p_m .* T_temp),\n        k_T_p_v2 = cu(p.T_v2_fact .* T_temp),\n        k_T_m_v2 = cu(p.T_v2_fact .* p.T_p_m .* T_temp),\n        dim_i = size(img)[1],\n        dim_j = size(img)[2],\n        x_V2 = cu(reshape(zeros(Float32, size(img)[1], size(img)[2] * p.K), size(img)[1], size(img)[2],p.K,1)),\nν_pw_n= p.ν^p.n, )\n\t\n# \ttemp_out = (\n#         k_gauss_1 = reshape2d_4d(Kernel.gaussian(p.σ_1)),\n#         k_gauss_2 = reshape2d_4d(Kernel.gaussian(p.σ_2)),\n#         k_C_d = C_Q_temp,\n#         k_C_b = C_P_temp,\n\t\t\n# # \t\ttodo use mean of x_lgn?\n# \t\tk_x_lgn = reshape(ones(Float32,1,p.K),1,1,p.K,1),\n# # \t\tk_x_lgn = CuArray((reshape(ones(Float32,1,p.K),1,1,p.K,1))./p.K),\n#         k_W_p = W_temp,\n#         k_W_m = W_temp,\n#         k_H = H_temp,\n#         k_T_p = T_temp,\n#         k_T_m = p.T_p_m .* T_temp,\n#         k_T_p_v2 = p.T_v2_fact .* T_temp,\n#         k_T_m_v2 = p.T_v2_fact .* p.T_p_m .* T_temp,\n#         dim_i = size(img)[1],\n#         dim_j = size(img)[2],\n#         x_V2 = reshape(zeros(Float32, size(img)[1], size(img)[2] * p.K), size(img)[1], size(img)[2],p.K,1),\n# ν_pw_n= p.ν^p.n, )\nmerge(p, temp_out)\nend\n\nfunction kernels_(img::AbstractArray, p::NamedTuple)\n       C_Q_temp = reshape(\n        Array{eltype(img)}(undef, p.C_AB_l, p.C_AB_l * p.K),\n        p.C_AB_l,\n        p.C_AB_l,\n        1,\n\t\tp.K\n    )\nC_P_temp = similar(C_Q_temp)\n\t    H_temp = reshape(\n        zeros(eltype(img), p.H_l, p.H_l * p.K * p.K),\n        p.H_l,\n        p.H_l,\n        p.K,\n    p.K)\n T_temp = reshape(Array{eltype(img)}(undef, p.K * p.K), 1, 1, p.K, p.K)     \n W_temp =\n        reshape(Array{eltype(img)}(undef, p.W_l, p.W_l * p.K * p.K), p.W_l, p.W_l, p.K, p.K)\n    for k ∈ 1:p.K\n        θ = π * (k - 1.0f0) / p.K\n        C_Q_temp[:, :, 1,k] = LamKernels.kern_d(p.σ_2, θ)          \n        C_P_temp[:, :, 1,k] = LamKernels.kern_b(p.σ_2, θ)               \n        H_temp[:, :, k,k] = p.H_fact .* LamKernels.gaussian_rot(p.H_σ_x, p.H_σ_y, θ, p.H_l)  \n# \t\ttodo make T kernel more general for higher K\n        T_temp[1, 1, k,1] = p.T_fact[k]\n        T_temp[1, 1, 2,2] = p.T_fact[1]\n        T_temp[1, 1, 1,2] = p.T_fact[2]\n        #todo: generalise T and W for higher K\n        #         T_temp[:,:,k] = KernelFactors.gaussian(p.T_σ, p.K)\n        #         for l ∈ 1:p.K\n        #             W_temp[:,:,l,k] =\n        #         end\n    end\n\n    W_temp[:, :, 1, 1] =\n        5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n        LamKernels.gaussian_rot(0.4f0, 1f0, 0f0, p.W_l)\n    \n\tW_temp[:, :, 2, 2] =\n        5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0,  π / 2f0, p.W_l) .+\n        LamKernels.gaussian_rot(0.4f0, 1f0, π / 2f0, p.W_l)\n    \n\tW_temp[:, :, 1, 2] = relu.(\n        0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n        LamKernels.gaussian_rot(0.3f0, 1.2f0, 0f0, p.W_l))\n    \n\tW_temp[:, :, 2, 1] = relu.(\n        0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, π / 2f0, p.W_l) .-\n        LamKernels.gaussian_rot(0.3f0, 1.2f0, π / 2f0, p.W_l))\n\t\n#     W_temp[:, :, 1, 1] =\n#         5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n#         LamKernels.gaussian_rot(0.4f0, 1f0, 0f0, p.W_l)\n#     W_temp[:, :, 2, 2] =\n#         5f0 .* LamKernels.gaussian_rot(3f0, 0.8f0, 0f0, p.W_l) .+\n#         LamKernels.gaussian_rot(0.4f0, 1f0, π / 2f0, p.W_l)\n#     W_temp[:, :, 1, 2] = relu.(\n#         0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n#         LamKernels.gaussian_rot(0.3f0, 1.2f0, 0f0, p.W_l))\n#     W_temp[:, :, 2, 1] = relu.(\n#         0.2f0 .- LamKernels.gaussian_rot(2f0, 0.6f0, 0f0, p.W_l) .-\n#         LamKernels.gaussian_rot(0.3f0, 1.2f0, π / 2f0, p.W_l))\n\t\n# temp_out = (\n#         k_gauss_1 = cu(reshape2d_4d(Kernel.gaussian(p.σ_1))),\n#         k_gauss_2 = cu(reshape2d_4d(Kernel.gaussian(p.σ_2))),\n#         k_C_d = cu(C_Q_temp),\n#         k_C_b = cu(C_P_temp),\n\t\t\n# # \t\ttodo use mean of x_lgn?\n# \t\tk_x_lgn = cu(reshape(ones(Float32,1,p.K),1,1,p.K,1)),\n# # \t\tk_x_lgn = CuArray((reshape(ones(Float32,1,p.K),1,1,p.K,1))./p.K),\n#         k_W_p = cu(W_temp),\n#         k_W_m = cu(W_temp),\n#         k_H = cu(H_temp),\n#         k_T_p = cu(T_temp),\n#         k_T_m = cu(p.T_p_m .* T_temp),\n#         k_T_p_v2 = cu(p.T_v2_fact .* T_temp),\n#         k_T_m_v2 = cu(p.T_v2_fact .* p.T_p_m .* T_temp),\n#         dim_i = size(img)[1],\n#         dim_j = size(img)[2],\n#         x_V2 = cu(reshape(zeros(Float32, size(img)[1], size(img)[2] * p.K), size(img)[1], size(img)[2],p.K,1)),\n# ν_pw_n= p.ν^p.n, )\n\t\n\ttemp_out = (\n        k_gauss_1 = reshape2d_4d(Kernel.gaussian(p.σ_1)),\n        k_gauss_2 = reshape2d_4d(Kernel.gaussian(p.σ_2)),\n        k_C_d = C_Q_temp,\n        k_C_b = C_P_temp,\n\t\t\n# \t\ttodo use mean of x_lgn?\n\t\tk_x_lgn = reshape(ones(Float32,1,p.K),1,1,p.K,1),\n# \t\tk_x_lgn = CuArray((reshape(ones(Float32,1,p.K),1,1,p.K,1))./p.K),\n        k_W_p = W_temp,\n        k_W_m = W_temp,\n        k_H = H_temp,\n        k_T_p = T_temp,\n        k_T_m = p.T_p_m .* T_temp,\n        k_T_p_v2 = p.T_v2_fact .* T_temp,\n        k_T_m_v2 = p.T_v2_fact .* p.T_p_m .* T_temp,\n        dim_i = size(img)[1],\n        dim_j = size(img)[2],\n        x_V2 = reshape(zeros(Float32, size(img)[1], size(img)[2] * p.K), size(img)[1], size(img)[2],p.K,1),\nν_pw_n= p.ν^p.n, )\nmerge(p, temp_out)\nend\n\n\n\n\nfunction reshape2d_4d(img::AbstractArray)\n    reshape(img, size(img)[1], size(img)[2], 1, 1)\nend\n\n# function reshape_ijk_ij1k(img::AbstractArray, p::NamedTuple)\n#     reshape(img, size(img)[1], size(img)[2], 1, p.K)\n# end\n\t\n\t\nfunction conv!(out::AbstractArray, img::AbstractArray, kern::AbstractArray, p::NamedTuple)\n# \tout_ = @view out[:,:,:,:]\n# \timg_ = @view img[:,:,:,:]\n# \tkern_ = @view kern[:,:,:,:]\n# \t    @inbounds out .= NNlib.conv(img[:,:,:,:], kern, pad=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipped=true)\n\t\n#     @inbounds out .= NNlib.conv(img, kern, pad=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipped=true)\n# \t    @inbounds out .= NNlib.conv(img_, kern_, pad=(size(kern_)[1]>>1, size(kern_)[1]>>1, size(kern_)[2]>>1, size(kern_)[2]>>1), flipped=true)\n\t\t    @inbounds NNlib.conv!(out, img, kern, NNlib.DenseConvDims(img, kern, padding=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipkernel=true))\n# \t@. out_ = out\n    return nothing\nend\n\n# function conv!(out::AbstractArray, img::AbstractArray, kern::AbstractArray, p::NamedTuple)\n# # \tout_ = @view out[:,:,:,:]\n#     @inbounds out = NNlib.conv(img, kern, pad=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipped=true)\n# # \t@. out_ = out\n#     return nothing\n# end\n\nfunction add_I_u_p(I::AbstractArray, p::NamedTuple)\n# \ttodo fix\n# \tI_4d = cu(reshape2d_4d(I))\n\tI_4d = reshape2d_4d(I)\n\tr = similar(I_4d)\n\tI_u!(r, I_4d, p)\n    temp_out = (I = I_4d, r = r)\n    return merge(p, temp_out)\nend\n\n\n# retina\n\nfunction I_u!(r::AbstractArray, I::AbstractArray, p::NamedTuple)\n\tconv!(r, I, p.k_gauss_1, p)\n    @. r = I - r\nend\n\n\n\n# lgn feedback\n\n# function fun_x_lgn!(x_lgn::AbstractArray, x::AbstractArray, p::NamedTuple)\n# # \tout_ = @view x_lgn[:,:,:,:]\n# \t    @inbounds x_lgn .= NNlib.conv(x[:,:,:,:], p.k_x_lgn, pad=0,flipped=true)\n#     return nothing\n# end\n\n\nfunction fun_x_lgn!(x_lgn::AbstractArray, x::AbstractArray, p::NamedTuple)\n# \tout_ = @view x_lgn[:,:,:,:]\n# \tx_ = @view x[:,:,:,:]\n# \tkern_ = @view p.k_x_lgn[:,:,:,:]\n# \t    @inbounds x_lgn .= NNlib.conv(x_, p.k_x_lgn, pad=0,flipped=true)\n\t\n\t\t    @inbounds NNlib.conv!(x_lgn, x, p.k_x_lgn, NNlib.DenseConvDims(x, p.k_x_lgn, padding=0, flipkernel=true))\n\t\n    return nothing\nend\n# function fun_F(value::Real, p::NamedTuple)\n#     max.(value - p.Γ, 0)\n# end\n#\n#\n# # williomson uses differnt F, relu with threshold\n# function fun_F_willimson(value::Real, p::NamedTuple)\n#     value < p.Γ ? zero(value) : value\n# end\n\n\n\n\nfunction fun_f!(arr::AbstractArray, p::NamedTuple)\n   @inbounds @. arr = (p.μ * arr^p.n) / (p.ν_pw_n + arr^p.n)\n    return nothing\nend\n\n\n# LGN\nfunction fun_dv!(\n    dv::AbstractArray,\n    v::AbstractArray,\n    u::AbstractArray,\n    x_lgn::AbstractArray,\n\tdv_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n\t\tconv!(dv_temp, x_lgn, p.k_gauss_1, p)\n    @. dv =\n        p.δ_v * (\n            -v + ((1f0 - v) * max(u, 0f0) * (1f0 + p.C_1 * x_lgn)) -\n            ((1f0 + v) * p.C_2 * dv_temp)\n        )\n\tend\n    return nothing\nend\n\n\n# lgn to l6 and l4\n# function fun_v_C!(\n#     v_C::AbstractArray,\n#     v_p::AbstractArray,\n#     v_m::AbstractArray, \n# \tV_temp_1::AbstractArray,\n# \tV_temp_2::AbstractArray,\n# \tQ_temp::AbstractArray,\n# \tP_temp::AbstractArray,\n#     p::NamedTuple,\n# )\n# #     V = similar(v_p)\n# #     temp = similar(v_p)\n\n# # \tA = similar(v_C)\n# # \tB = similar(v_C)\n#     #     allocate B to v_C\n\t\n# # \tmx_v_p = similar(v_p)\n\t\n# # \t@. mx_v_p = max(v_p,0f0)\n\t\n#     @inbounds @. V_temp_2 = exp(-1.0f0 / 8.0f0) * (max(v_p[:,:,:,:], 0f0) - max(v_m[:,:,:,:], 0f0))\n#     conv!(V_temp_1, V_temp_2, p.k_gauss_2, p)\n\n   \n    \n# \tconv!(Q_temp, V_temp_1, p.k_C_d, p)\n# \tconv!(P_temp, V_temp_1, p.k_C_b, p)\n# # \t@. P_temp = abs(v_C)\n# \t@inbounds @. P_temp = abs(v_C[:,:,:,:])\n\t\n\t\n#     @inbounds @. v_C = p.γ * (max(Q_temp[:,:,:,:] - P_temp[:,:,:,:], 0f0) + max(-Q_temp[:,:,:,:] - P_temp[:,:,:,:], 0f0))\n\t\n\t\n#     return nothing\n# end\n\nfunction fun_v_C!(\n    v_C::AbstractArray,\n    v_p::AbstractArray,\n    v_m::AbstractArray, \n\tV_temp_1::AbstractArray,\n\tV_temp_2::AbstractArray,\n\tQ_temp::AbstractArray,\n\tP_temp::AbstractArray,\n    p::NamedTuple,\n)\n#     V = similar(v_p)\n#     temp = similar(v_p)\n\n# \tA = similar(v_C)\n# \tB = similar(v_C)\n    #     allocate B to v_C\n\t\n# \tmx_v_p = similar(v_p)\n\t\n# \t@. mx_v_p = max(v_p,0f0)\n\t\n    @inbounds begin\n\t\t@. V_temp_2 = exp(-1.0f0 / 8.0f0) * (max(v_p, 0f0) - max(v_m, 0f0))\n    conv!(V_temp_1, V_temp_2, p.k_gauss_2, p)\n\n   \n    \n\tconv!(Q_temp, V_temp_1, p.k_C_d, p)\n\tconv!(P_temp, V_temp_1, p.k_C_b, p)\n# \t@. P_temp = abs(v_C)\n# \t@. P_temp = abs(v_C)\n\t\t@. P_temp = abs(P_temp)\n\t\n\t\n    @. v_C = p.γ * (max(Q_temp - P_temp, 0f0) + max(-Q_temp - P_temp, 0f0))\n\tend\n\t\n    return nothing\nend\n\n\n\n# L6\nfunction fun_dx_v1!(\n    dx::AbstractArray,\n    x::AbstractArray,\n    C::AbstractArray,\n    z::AbstractArray,\n    x_v2::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    @. dx =\n        p.δ_c * (\n            -x + (\n                (1.0f0 - x) * (\n                    (p.α * C) + (p.ϕ * max(z - p.Γ, 0f0)) .+ (p.v_21 * x_v2) +\n                    p.att\n                )\n            )\n        )\n\tend\n    return nothing\nend\n\n\n\n#     L4 excit\nfunction fun_dy!(\n    dy::AbstractArray,\n    y::AbstractArray,\n    C::AbstractArray,\n    x::AbstractArray,\n    m::AbstractArray,\n\t\tdy_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    conv!(dy_temp, m, p.k_W_p, p)\n    @. dy_temp = m * dy_temp\n    fun_f!(dy_temp, p)\n    @. dy = p.δ_c * (-y + ((1f0 - y) * (C + (p.η_p * x))) - ((1f0 + y) * dy_temp))\n\tend\n    return nothing\nend\n\n\n#     l4 inhib\nfunction fun_dm!(\n    dm::AbstractArray,\n    m::AbstractArray,\n    x::AbstractArray,\n\t\tdm_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    conv!(dm_temp, m, p.k_W_m, p)\n    fun_f!(dm_temp, p)\n    @. dm = p.δ_m * (-m + (p.η_m * x) - (m * dm_temp))\n\tend\n    return nothing\nend\n\n\n\n#     L2/3 excit\nfunction fun_dz!(\n    dz::AbstractArray,\n    z::AbstractArray,\n    y::AbstractArray,\n    H_z::AbstractArray,\n    s::AbstractArray,\n\t\tdz_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    conv!(dz_temp, s, p.k_T_p, p)\n    @. dz =\n        p.δ_z * (\n            -z + ((1f0 - z) * ((p.λ * max(y, 0f0)) + H_z + (p.a_23_ex * p.att))) -\n            ((z + p.ψ) * dz_temp)\n        )\n\tend\n    return nothing\nend\n\n#     L2/3 inhib\nfunction fun_ds!(\n    ds::AbstractArray,\n    s::AbstractArray,\n    H_z::AbstractArray,\n\t\tds_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    conv!(ds_temp, s, p.k_T_m, p)\n    @. ds = p.δ_s * (-s + H_z + (p.a_23_in * p.att) - (s * ds_temp))\n\t\tend\n\treturn nothing\nend\n\n\nfunction fun_H_z!(\n\t\tH_z::AbstractArray, \n\t\tz::AbstractArray, \n\t\tH_z_temp::AbstractArray, \n\t\tp::NamedTuple)\n\t@inbounds begin\n\t@. H_z_temp = max(z - p.Γ, 0f0)\n\tconv!(H_z, H_z_temp, p.k_H, p)\n\tend\n    return nothing\nend\n\n\n\n#     V2 L6\nfunction fun_dx_v2!(\n    dx::AbstractArray,\n    x_v2::AbstractArray,\n    z_v2::AbstractArray,\n    z::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    @. dx =\n        p.δ_c * (\n            -x_v2 + (\n                (1f0 - x_v2) * (\n                    (p.v12_6 * max(z - p.Γ, 0f0)) +\n                    (p.ϕ * max(z_v2 - p.Γ, 0f0)) +\n                    p.att\n                )\n            )\n        )\n\tend\n    return nothing\nend\n\n\n# V2 L4 excit\nfunction fun_dy_v2!(\n    dy::AbstractArray,\n    y_v2::AbstractArray,\n    z::AbstractArray,\n    x_v2::AbstractArray,\n    m_v2::AbstractArray,\n\t\tdy_temp::AbstractArray,\n    p::NamedTuple,\n)\n\t@inbounds begin\n    conv!(dy_temp, m_v2, p.k_W_p, p)\n    fun_f!(dy_temp, p)\n    @. dy =\n        p.δ_c * (\n            -y_v2 +\n            ((1.0f0 - y_v2) * ((p.v12_4 * max(z - p.Γ, 0f0)) + (p.η_p * x_v2))) -\n            ((1.0f0 + y_v2) * dy_temp)\n        )\n\tend\n    return nothing\nend\n\n\n\n# # for equilabrium\n# fun_equ(x) = x/(1+x)\n#\n#\n# # lgn\n# function fun_v_equ(u::AbstractArray, x::AbstractArray, p::NamedTuple)\n#     return fun_equ.(relu.(u) .* (p.lgn_equ_u .+ (p.lgn_equ_A .* fun_A.(x))) .- (p.lgn_equ_B .* fun_B.(x)))\n# end\n#\n#\n# # lgn, no L6 feedback, light\n# function fun_v_equ_noFb(u::AbstractArray, x::AbstractArray, p::NamedTuple)\n#     return fun_equ.(relu.(u) .* (p.lgn_para_u))\n# end\n#\n#\n# # l6\n# function fun_x_equ(C::AbstractArray, z::AbstractArray,  p::NamedTuple)\n#     return fun_equ.((p.α .* C) .+ (p.ϕ .* fun_F.(z,p.Γ)) + (p.V_21 .* x_v2) .+ p.att)\n# end\n#\n#\n# # l6, no V2 feedback, light\n# function fun_x_equ_noV2(C::AbstractArray, z::AbstractArray, p::NamedTuple)\n#     return fun_equ.((p.α .* C) .+ (p.ϕ .* fun_F.(z,p.Γ)))\n# end\n#\n#\n# # l4 excit\n# function fun_y_equ(C::AbstractArray, x::AbstractArray,  m::AbstractArray, p::NamedTuple)\n#     return fun_equ.(C .+ (η_p .* x - fun_f.(imfilter(m, p.k_W_p), p.μ, p.ν, p.n)))\n# end\n#\n# # l4 inhib, needs initial condition of itself\n# function fun_m_equ(C::AbstractArray, x::AbstractArray, m_init::AbstractArray, p::NamedTuple)\n#     return (p.η_m .* x ./ (1 .+  fun_f.(imfilter(m_init, p.k_W_m), p.μ, p.ν, p.n)))\n# end\n#\n#\n# # l4 inhib - no feedback kernel\n# function fun_m_equ_noFb(C::AbstractArray, x::AbstractArray, p::NamedTuple)\n#     return (p.η_m .* x)\n# end\n#\n#\n# #  l2/3 excit, needs initial condition of itself\n# function fun_z_equ(y::AbstractArray, s::AbstractArray,  z_init::AbstractArray,  p::NamedTuple)\n#     return (p.λ .* relu.(y)) .+ imfilter(fun_F.(z_init, p.Γ), k_H) .+ (p.a_23_ex .* p.att) .- (p.ϕ .* imfilter(s, k_T_p)) ./\n#     (1 .+ (p.λ .* relu.(y)) .+ imfilter(fun_F.(z_init, p.Γ), k_H) .+ (p.a_23_ex .* p.att) .+ imfilter(s, k_T_p))\n#     return\n# end\n#\n#\n# #  l2/3 excit - no feedback kernel\n# function fun_z_equ_noFb(y::AbstractArray, s::AbstractArray, p::NamedTuple)\n#     return (p.λ .* relu.(y)) .- (p.ϕ .* imfilter(s, k_T_p)) ./\n#     (1 .+ (p.λ .* relu.(y)) .+ imfilter(s, k_T_p))\n#     return\n# end\n#\n#\n# #  l2/3 inhib, needs initial condition of itself\n# function fun_s_equ(z::AbstractArray, s::AbstractArray,  s_init::AbstractArray, p::NamedTuple)\n#     return ((imfilter(fun_F.(z, p.Γ), k_H) + p.a_23_in .* p.att ) ./ (1 .+ imfilter(s_init, k_T_m)))           #????????? is T right?\n# end\n#\n#\n# #  l2/3 inhib - no feedback kernel\n# function fun_s_equ_noFb(z::AbstractArray, s::AbstractArray, p::NamedTuple)\n#     return (imfilter(fun_F.(z, p.Γ), k_H))\n# end\n#\n#\n# # V2 L6\n# function fun_xV2_equ(x_v2::AbstractArray, z::AbstractArray, z_v2::AbstractArray, p::NamedTuple)\n#     return fun_equ.((p.V_12_6 .* fun_F.(z, p.Γ) .+ (p.ϕ .* fun_F.(z_v2, p.Γ))))\n# end\n#\n#\n# #  V2 L4 excit\n# function fun_yV2_equ(z::AbstractArray, x::AbstractArray,  m::AbstractArray, p::NamedTuple)\n#     return (p.V_12_4 .* fun_F.(z,p.Γ) .+ (p.η_p .* x) - fun_f.(imfilter(m, k_W_p), p.μ, p.ν, p.n) ./\n#    (1 .+ p.V_12_4 .* fun_F.(z,p.Γ) .+ (p.η_p .* x) .+ fun_f.(imfilter(m, k_W_p), p.μ, p.ν, p.n)))\n# end\n\nend\n\n\n\n\n\n# function varables(I::AbstractArray, p::NamedTuple)\n#    v_p = zeros(typeof(I[1,1]), size(I)[1], size(I)[2])\n#    v_m = copy(v_p)\n#    x_lgn = copy(v_p)\n#    x = reshape(zeros(typeof(I[1,1]), size(I)[1], size(I)[2] * p.K), size(I)[1], size(I)[2], p.K)\n#    y = copy(x)\n#    m = copy(x)\n#    z = copy(x)\n#    s = copy(x)\n#    C = copy(x)\n#    H_z = copy(x)\n#    x_V2 = copy(x)\n#    y_V2 = copy(x)\n#    m_V2 = copy(x)\n#    z_V2 = copy(x)\n#    s_V2 = copy(x)\n#    H_z_V2 = copy(x)\n#    return [v_p, v_m, x_lgn, x, y, m, z, s, C, H_z, x_V2, y_V2, m_V2, z_V2, s_V2, H_z_V2]\n# end\n#\n#\n# function variables_sep(I::AbstractArray, p::NamedTuple)\n#    v_p = zeros(typeof(I[1,1]), size(I)[1], size(I)[2])\n#    v_m = copy(v_p)\n#    x_lgn = copy(v_p)\n#    x = reshape(zeros(typeof(I[1,1]), size(I)[1], size(I)[2] * p.K), size(I)[1], size(I)[2], p.K)\n#    y = copy(x)\n#    m = copy(x)\n#    z = copy(x)\n#    s = copy(x)\n#    C = copy(x)\n#    H_z = copy(x)\n#    x_V2 = copy(x)\n#    y_V2 = copy(x)\n#    m_V2 = copy(x)\n#    z_V2 = copy(x)\n#    s_V2 = copy(x)\n#    H_z_V2 = copy(x)\n#    return v_p, v_m, x_lgn, x, y, m, z, s, C, H_z, x_V2, y_V2, m_V2, z_V2, s_V2, H_z_V2\n# end\n#\n# function variables_dict(I::AbstractArray, p::NamedTuple)\n#    v_p = zeros(typeof(I[1,1]), size(I)[1], size(I)[2])\n#    v_m = copy(v_p)\n#    x_lgn = copy(v_p)\n#    x = reshape(zeros(typeof(I[1,1]), size(I)[1], size(I)[2] * p.K), size(I)[1], size(I)[2], p.K)\n#    y = copy(x)\n#    m = copy(x)\n#    z = copy(x)\n#    s = copy(x)\n#    C = copy(x)\n#    H_z = copy(x)\n#    x_V2 = copy(x)\n#    y_V2 = copy(x)\n#    m_V2 = copy(x)\n#    z_V2 = copy(x)\n#    s_V2 = copy(x)\n#    H_z_V2 = copy(x)\n#    return v_p, v_m, x_lgn, x, y, m, z, s, C, H_z, x_V2, y_V2, m_V2, z_V2, s_V2, H_z_V2\n# end\n\n# function varables(I::AbstractArray, p::NamedTuple)\n#    ij = zeros(typeof(I[1,1]), size(I)[1], size(I)[2])\n#    ijk = reshape(zeros(typeof(I[1,1]), size(I)[1], size(I)[2] * p.K), size(I)[1], size(I)[2], p.K)\n#    temp_out = [v_p = copy(ij),\n#    v_m = copy(ij),\n#    x_lgn = copy(ij),\n#    x = copy(ijk),\n#    y = copy(ijk),\n#    m = copy(ijk),\n#    z = copy(ijk),\n#    s = copy(ijk),\n#    C = copy(ijk),\n#    H_z = copy(ijk),\n#    x_V2 = copy(ijk),\n#    y_V2 = copy(ijk),\n#    m_V2 = copy(ijk),\n#    z_V2 = copy(ijk),\n#    s_V2 = copy(ijk),\n#    H_z_V2 = copy(ijk)]\n#    return temp_out\n# end
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/LaminartGPU.jl	(revision 2a62781ebc3bb905c836593b225086931e46fdbd)
+++ src/LaminartGPU.jl	(date 1597057327323)
@@ -1027,7 +1027,7 @@
 	
 #     @inbounds out .= NNlib.conv(img, kern, pad=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipped=true)
 # 	    @inbounds out .= NNlib.conv(img_, kern_, pad=(size(kern_)[1]>>1, size(kern_)[1]>>1, size(kern_)[2]>>1, size(kern_)[2]>>1), flipped=true)
-		    @inbounds NNlib.conv!(out, img, kern, NNlib.DenseConvDims(img, kern, padding=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipkernel=true))
+	@inbounds NNlib.conv!(out, img, kern, NNlib.DenseConvDims(img, kern, padding=(size(kern)[1]>>1, size(kern)[1]>>1, size(kern)[2]>>1, size(kern)[2]>>1), flipkernel=true))
 # 	@. out_ = out
     return nothing
 end
